import socket
#                                  #notacao de retorno de funcao
# def strEthernet(ethernet: bytes) -> bool: ,  -> None:  -> str:
#     ethernet = ethernet.hex().upper()

# declaracao de tipo em bytes -> (declaracao: tipo):


def strEthernet(ethernet: bytes):
    # .hex() - Create a string de numeros hexadecimais from a bytes object.
    # .upper() - Transforma string em uppercase
    ethernet = ethernet.hex().upper()
    ######### =====    FUNCAO DO STR ETHERNET   ======##########
    #            StrEthernet
    #            MAC ADDRESS em BYTES e formata ele de bytes para string
    #                Ex: ether 08:00:27:b5:52:74
    strEthernet = ""

    # do 0 ate o 10 e pula de dois em dois (+2)
    for i in range(0, 10, 2):
        # ethernet[1]  -> pegando o ethernet na posicao atual ate i
        # ate a posicao[i: --> (i+2)] i até i+2
        #                        0 até 2 -> pega os dois primeiros
        #                                   caracteres e concatena os dois pontos
        strEthernet += f" { ethernet[i:(i+2)] } : "
    strEthernet += ethernet[10:]
    return strEthernet

    # Analisa o Header do pacote Ethernet
    # pega so os 14 bytes iniciais do header


def parseEthernet(headers: bytes):
    etherDestino = headers[:6]  # split de listas
    etherFonte = headers[6:12]  # do 6 ao 11 incluido mas o 12 nao
    etherTipo = headers[12:]
    print("###[ Ethernet ]###")
    print(f" Fonte:t\ {strEthernet(etherFonte)}")
    print(f" Destino:t\ {strEthernet(etherDestino)}")
    # Se o etherTipe for igual aos etherTipe do protocolo IPV4
    # retorna um boleano True
    return etherTipo == b'\x08\x00'

    # Refere apenas ao headers da camada IP


def parseIP(headers: bytes):
    tipo = headers[9:10]  # pega so 9 byte
    ipFonte = headers[12:16]
    ipDestino = headers[16:20]
    # inet_ntoa() -> Já onverte um objeto de bytes e transforma em string
    print("###[ IP ]###")
    #           Nao precisa usar o strEthernet
    print(f" Fonte:t\ {socket.inet_ntoa(ipFonte)}")
    print(f" Destino:t\ {socket.inet_ntoa(ipDestino)}")
    if tipo == b'\x06':
        return 'TCP'
    if tipo == b'\x11':
        return 'UDP'
    return ''


def parseTCP(headers: bytes):
    # do 0 byte ate o 2
    portaFonte = int.from_bytes(headers[:2], byteorder='big')
    # do 2 byte ate o 4
    portaDestino = int.from_bytes(headers[2:4], byteorder='big')
    # define a leitura da ordem dos bytes na rede big Indiee
    print("###[TCP]###")
    print(f" Porta fonte:\t {portaFonte}")
    print(f" Porta destino:{portaDestino}")
    return portaFonte == 80  # -> todo protocolo http == True


def parseUDP(headers: bytes):
    portaFonte = headers[2:]
    portaDestino = headers[2:4]
    print("### UDP ####")
    print(f"  Porta fonte:\t {int.from_bytes(portaFonte, byteorder='big')}")
    print(f" Porta destino: {int.from_bytes(portaDestino, byteorder='big')}")

#CONTROI RAW SOCKET
rawSocket = socket.socket(
    socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x800))
while True:
    # captura do pacote
    rawPkt = rawSocket.recvfrom(2048)[0]
    print("\n\nPacote recebido:\n")
    #Tamanho do ethernet é 0-14 bytes
    #Se tiver camada ip ele entra e pega do 14 ao 34
    if parseEthernet(rawPkt[:14]):
                    #ele pega do 14 ate o 34 , 
                    # A partir do 34 comeca o pacote IP
                    #e taca no tipo de pacote
        tipoPkt = parseIP(rawPkt[14:34])
                                    #20 bytes do pacote IP 
        if tipoPkt:
            if tipoPkt == 'UDP':
                parseUDP(rawPkt[34:42])
            if tipoPkt == 'TCP':
                if parseTCP(rawPkt[34:54]):
                    print(rawPkt[54:])
